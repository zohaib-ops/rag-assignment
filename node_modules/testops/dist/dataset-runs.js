"use strict";
/**
 * Dataset Runs API client for TestOps.
 *
 * This module provides CRUD operations for dataset runs and dataset run items through the TestOps API.
 * Mirrors the Python SDK's dataset_runs.py structure exactly.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatasetRuns = exports.DatasetRunsClient = exports.DatasetRunType = exports.DatasetRunStatus = void 0;
exports.createDatasetRuns = createDatasetRuns;
/**
 * Status constants for dataset runs
 */
class DatasetRunStatus {
}
exports.DatasetRunStatus = DatasetRunStatus;
DatasetRunStatus.OPEN = "OPEN";
DatasetRunStatus.PENDING = "PENDING";
DatasetRunStatus.COMPLETED = "COMPLETED";
/**
 * Type constants for dataset runs
 */
class DatasetRunType {
}
exports.DatasetRunType = DatasetRunType;
DatasetRunType.MUTABLE = "MUTABLE";
DatasetRunType.IMMUTABLE = "IMMUTABLE";
/**
 * Client for managing dataset runs through the TestOps API.
 * This is a thin wrapper that provides dataset run functionality.
 * Mirrors the Python SDK's DatasetRunsClient structure exactly.
 */
class DatasetRunsClient {
    /**
     * Initialize the dataset runs client.
     *
     * @param baseUrl The base URL for the TestOps API
     * @param publicKey The public API key
     * @param secretKey The secret API key
     */
    constructor(baseUrl, publicKey, secretKey) {
        if (!baseUrl || !publicKey || !secretKey) {
            throw new Error('baseUrl, publicKey, and secretKey are required');
        }
        this.baseUrl = baseUrl.replace(/\/$/, '');
        this.publicKey = publicKey;
        this.secretKey = secretKey;
    }
    /**
     * Generate authentication headers for requests.
     */
    _getAuthHeaders() {
        const authString = Buffer.from(`${this.publicKey}:${this.secretKey}`).toString('base64');
        return {
            'Authorization': `Basic ${authString}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
    }
    /**
     * Validate dataset name format.
     *
     * @param datasetName The dataset name to validate
     * @throws Error If the dataset name is invalid
     */
    _validateDatasetName(datasetName) {
        if (!datasetName || typeof datasetName !== 'string') {
            throw new Error('dataset_name must be a non-empty string');
        }
    }
    /**
     * Validate dataset run ID format.
     *
     * @param datasetRunId The dataset run ID to validate
     * @throws Error If the dataset run ID is invalid
     */
    _validateDatasetRunId(datasetRunId) {
        if (!datasetRunId || typeof datasetRunId !== 'string') {
            throw new Error('dataset_run_id must be a non-empty string');
        }
    }
    /**
     * Create a new dataset run.
     *
     * @param datasetName The name of the dataset to create a run for
     * @param name Optional name for the dataset run
     * @param description Optional description for the dataset run
     * @param metadata Optional metadata for the dataset run
     * @param tag Optional tag for the dataset run (only allowed for MUTABLE runs)
     * @returns DatasetRunResponse containing the created dataset run data
     * @throws Error If input validation fails or API request fails
     */
    async create(datasetName, name, description, metadata, tag) {
        this._validateDatasetName(datasetName);
        // Validate tag usage
        if (tag !== undefined) {
            if (typeof tag !== 'string' || !tag.trim()) {
                throw new Error('tag must be a non-empty string');
            }
        }
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs`;
        const payload = {};
        if (name !== undefined) {
            payload.name = name;
        }
        if (description !== undefined) {
            payload.description = description;
        }
        if (metadata !== undefined) {
            payload.metadata = metadata;
        }
        if (tag !== undefined) {
            payload.tags = [tag.trim()];
        }
        // Use native fetch - simple thin wrapper
        const response = await fetch(url, {
            method: 'POST',
            headers: this._getAuthHeaders(),
            body: JSON.stringify(payload),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * List dataset runs for a dataset.
     *
     * @param datasetName The name of the dataset
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @param name Optional filter by run name
     * @param type Optional filter by run type ("IMMUTABLE" or "MUTABLE")
     * @returns ListDatasetRunsResponse containing dataset runs list and pagination info
     * @throws Error If input validation fails or API request fails
     */
    async list(datasetName, page = 1, limit = 50, name, type) {
        this._validateDatasetName(datasetName);
        if (!Number.isInteger(page) || page < 1) {
            throw new Error('page must be a positive integer');
        }
        if (!Number.isInteger(limit) || limit < 1 || limit > 100) {
            throw new Error('limit must be a positive integer between 1 and 100');
        }
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs`;
        const params = new URLSearchParams({
            page: page.toString(),
            limit: limit.toString(),
        });
        if (name !== undefined) {
            params.append('name', name);
        }
        if (type !== undefined) {
            params.append('type', type);
        }
        // Use native fetch - simple thin wrapper
        const response = await fetch(`${url}?${params.toString()}`, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * List items in a dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns ListDatasetRunItemsResponse containing dataset run items list and pagination info
     * @throws Error If input validation fails or API request fails
     */
    async listItems(datasetName, datasetRunId, page = 1, limit = 50) {
        this._validateDatasetName(datasetName);
        this._validateDatasetRunId(datasetRunId);
        if (!Number.isInteger(page) || page < 1) {
            throw new Error('page must be a positive integer');
        }
        if (!Number.isInteger(limit) || limit < 1 || limit > 100) {
            throw new Error('limit must be a positive integer between 1 and 100');
        }
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs/${datasetRunId}/items`;
        const params = new URLSearchParams({
            page: page.toString(),
            limit: limit.toString(),
        });
        // Use native fetch - simple thin wrapper
        const response = await fetch(`${url}?${params.toString()}`, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Create/upload multiple items to a dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param items List of item objects, each containing item data
     * @returns CreateDatasetRunItemsResponse containing the bulk creation results
     * @throws Error If input validation fails or API request fails
     */
    async createItems(datasetName, datasetRunId, items) {
        this._validateDatasetName(datasetName);
        this._validateDatasetRunId(datasetRunId);
        if (!items || !Array.isArray(items)) {
            throw new Error('items must be a non-empty array');
        }
        if (items.length === 0) {
            throw new Error('items must be a non-empty array');
        }
        if (items.length > 1000) {
            throw new Error('Maximum 1000 items per batch');
        }
        // Validate each item has required fields
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (typeof item !== 'object' || item === null) {
                throw new Error(`Item at index ${i} must be an object`);
            }
            if (!('input' in item) && !('expectedOutput' in item)) {
                throw new Error(`Item at index ${i} must have at least 'input' or 'expectedOutput'`);
            }
        }
        // Use the main items endpoint for bulk creation
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs/${datasetRunId}/items`;
        const payload = { items };
        try {
            console.log(`📦 Creating ${items.length} dataset items...`);
            // Use native fetch - simple thin wrapper
            const response = await fetch(url, {
                method: 'POST',
                headers: this._getAuthHeaders(),
                body: JSON.stringify(payload),
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const result = await response.json();
            if (result.success) {
                console.log(`✅ Successfully created ${result.itemCount} items`);
            }
            else {
                console.log(`⚠️  Creation returned success=false`);
            }
            return result;
        }
        catch (e) {
            console.log(`❌ Creation failed: ${e}`);
            throw e;
        }
    }
    /**
     * Get the most recent OPEN dataset run with the specified tag.
     *
     * @param datasetName The name of the dataset
     * @param tagName The tag name to search for
     * @returns GetDatasetRunByTagResponse containing the dataset run data
     * @throws Error If input validation fails or API request fails
     */
    async getRunByTag(datasetName, tagName) {
        this._validateDatasetName(datasetName);
        if (!tagName || typeof tagName !== 'string') {
            throw new Error('tag_name must be a non-empty string');
        }
        // Validate tag name format (same as backend validation)
        const trimmedTagName = tagName.trim();
        if (!trimmedTagName) {
            throw new Error('Tag name cannot be empty');
        }
        if (trimmedTagName.length > 50) {
            throw new Error('Tag name cannot exceed 50 characters');
        }
        if (!/^[a-zA-Z0-9_-]+$/.test(trimmedTagName)) {
            throw new Error('Tag name can only contain letters, numbers, underscores, and hyphens');
        }
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs/tags/${trimmedTagName}`;
        // Use native fetch - simple thin wrapper
        const response = await fetch(url, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Get tags for a specific dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns GetDatasetRunTagsResponse containing dataset run tags list and pagination info
     * @throws Error If input validation fails or API request fails
     */
    async getRunTags(datasetName, datasetRunId, page = 1, limit = 50) {
        this._validateDatasetName(datasetName);
        this._validateDatasetRunId(datasetRunId);
        if (!Number.isInteger(page) || page < 1) {
            throw new Error('page must be a positive integer');
        }
        if (!Number.isInteger(limit) || limit < 1 || limit > 100) {
            throw new Error('limit must be a positive integer between 1 and 100');
        }
        const url = `${this.baseUrl}/api/public/datasets/${datasetName}/runs/${datasetRunId}/tags`;
        const params = new URLSearchParams({
            page: page.toString(),
            limit: limit.toString(),
        });
        // Use native fetch - simple thin wrapper
        const response = await fetch(`${url}?${params.toString()}`, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
}
exports.DatasetRunsClient = DatasetRunsClient;
/**
 * Convenience wrapper for dataset runs operations.
 *
 * Provides a simple interface for CRUD operations on dataset runs and items.
 */
class DatasetRuns {
    /**
     * Initialize with a dataset runs client.
     *
     * @param client The dataset runs client instance
     */
    constructor(client) {
        this._client = client;
    }
    /**
     * Create a new dataset run.
     *
     * @param datasetName The name of the dataset to create a run for
     * @param options Additional options for the dataset run
     * @returns DatasetRunResponse containing the created dataset run data
     */
    async create(datasetName, options) {
        return this._client.create(datasetName, options?.name, options?.description, options?.metadata, options?.tag);
    }
    /**
     * List dataset runs for a dataset.
     *
     * @param datasetName The name of the dataset
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @param name Optional filter by run name
     * @param type Optional filter by run type
     * @returns ListDatasetRunsResponse containing dataset runs list and pagination info
     */
    async list(datasetName, page, limit, name, type) {
        return this._client.list(datasetName, page, limit, name, type);
    }
    /**
     * List items in a dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns ListDatasetRunItemsResponse containing dataset run items list and pagination info
     */
    async listItems(datasetName, datasetRunId, page, limit) {
        return this._client.listItems(datasetName, datasetRunId, page, limit);
    }
    /**
     * Create/upload multiple items to a dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param items List of item objects, each containing item data
     * @returns CreateDatasetRunItemsResponse containing the bulk creation results
     */
    async createItems(datasetName, datasetRunId, items) {
        return this._client.createItems(datasetName, datasetRunId, items);
    }
    /**
     * Get the most recent OPEN dataset run with the specified tag.
     *
     * @param datasetName The name of the dataset
     * @param tagName The tag name to search for
     * @returns GetDatasetRunByTagResponse containing the dataset run data
     */
    async getRunByTag(datasetName, tagName) {
        return this._client.getRunByTag(datasetName, tagName);
    }
    /**
     * Get tags for a specific dataset run.
     *
     * @param datasetName The name of the dataset
     * @param datasetRunId The ID of the dataset run
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns GetDatasetRunTagsResponse containing dataset run tags list and pagination info
     */
    async getRunTags(datasetName, datasetRunId, page, limit) {
        return this._client.getRunTags(datasetName, datasetRunId, page, limit);
    }
}
exports.DatasetRuns = DatasetRuns;
/**
 * Factory function to create a DatasetRuns instance
 *
 * @param baseUrl The base URL for the TestOps API
 * @param publicKey The public API key
 * @param secretKey The secret API key
 * @returns DatasetRuns instance ready for use
 */
function createDatasetRuns(baseUrl, publicKey, secretKey) {
    const client = new DatasetRunsClient(baseUrl, publicKey, secretKey);
    return new DatasetRuns(client);
}
//# sourceMappingURL=dataset-runs.js.map