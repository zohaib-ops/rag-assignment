"use strict";
/**
 * Experiments API client for TestOps.
 *
 * This module provides operations for experiments through the TestOps API.
 * Mirrors the Python SDK's experiments.py structure exactly.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Experiments = exports.ExperimentsClient = void 0;
exports.createExperiments = createExperiments;
/**
 * Client for managing experiments through the TestOps API.
 */
class ExperimentsClient {
    /**
     * Initialize the experiments client.
     *
     * @param baseUrl The base URL for the TestOps API
     * @param publicKey The public API key
     * @param secretKey The secret API key
     */
    constructor(baseUrl, publicKey, secretKey) {
        if (!baseUrl || !publicKey || !secretKey) {
            throw new Error('baseUrl, publicKey, and secretKey are required');
        }
        this.baseUrl = baseUrl.replace(/\/$/, '');
        this.publicKey = publicKey;
        this.secretKey = secretKey;
    }
    /**
     * Generate authentication headers for requests.
     */
    _getAuthHeaders() {
        const authString = Buffer.from(`${this.publicKey}:${this.secretKey}`).toString('base64');
        return {
            'Authorization': `Basic ${authString}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
    }
    /**
     * Validate experiment ID format.
     *
     * @param experimentId The experiment ID to validate
     * @throws Error If the experiment ID is invalid
     */
    _validateExperimentId(experimentId) {
        if (!experimentId || typeof experimentId !== 'string') {
            throw new Error('experiment_id must be a non-empty string');
        }
    }
    /**
     * Validate pagination parameters.
     *
     * @param page The page number to validate
     * @param limit The limit to validate
     * @param maxLimit The maximum allowed limit
     * @throws Error If pagination parameters are invalid
     */
    _validatePaginationParams(page, limit, maxLimit = 100) {
        if (page < 1) {
            throw new Error('page must be >= 1');
        }
        if (limit < 1 || limit > maxLimit) {
            throw new Error(`limit must be between 1 and ${maxLimit}`);
        }
    }
    /**
     * Validate experiment creation request data.
     *
     * @param requestData The request data to validate
     * @throws Error If validation fails
     */
    _validateCreateRequest(requestData) {
        if (!requestData || typeof requestData !== 'object') {
            throw new Error('request_data must be a non-empty object');
        }
        if (!requestData.name || typeof requestData.name !== 'string') {
            throw new Error('name is required');
        }
        if (!requestData.experimentEvaluatorId || typeof requestData.experimentEvaluatorId !== 'string') {
            throw new Error('experimentEvaluatorId is required');
        }
        // Check if this is a tag-based or prompt-based request
        const hasDatasetRunTag = 'datasetRunTagId' in requestData && requestData.datasetRunTagId;
        const hasPrompt = 'promptId' in requestData && requestData.promptId;
        const hasDataset = 'datasetId' in requestData && requestData.datasetId;
        if (!hasDatasetRunTag && !(hasPrompt && hasDataset)) {
            throw new Error('Either datasetRunTagId or both promptId and datasetId are required');
        }
        if (hasDatasetRunTag && hasPrompt) {
            throw new Error('Cannot specify both datasetRunTagId and promptId');
        }
    }
    /**
     * Create a new experiment.
     *
     * @param requestData The experiment creation request data
     * @returns Promise<ExperimentResponse> containing the created experiment
     * @throws Error If input validation fails or API request fails
     */
    async create(requestData) {
        this._validateCreateRequest(requestData);
        const url = `${this.baseUrl}/api/public/experiments`;
        const response = await fetch(url, {
            method: 'POST',
            headers: this._getAuthHeaders(),
            body: JSON.stringify(requestData),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * List experiments with pagination.
     *
     * @param limit Maximum number of experiments to return (default: 50)
     * @param page Page number for pagination (default: 1)
     * @returns Promise<ListExperimentsResponse> containing the list of experiments and total count
     * @throws Error If input validation fails or API request fails
     */
    async list(limit = 50, page = 1) {
        this._validatePaginationParams(page, limit, 100);
        const url = new URL(`${this.baseUrl}/api/public/experiments`);
        url.searchParams.set('limit', limit.toString());
        url.searchParams.set('page', page.toString());
        const response = await fetch(url.toString(), {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Get a single experiment by ID.
     *
     * @param experimentId The ID of the experiment to retrieve
     * @returns Promise<ExperimentResponse> containing the experiment data
     * @throws Error If input validation fails or experiment is not found
     */
    async find(experimentId) {
        this._validateExperimentId(experimentId);
        const url = `${this.baseUrl}/api/public/experiments/${experimentId}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            if (response.status === 404) {
                throw new Error(`Experiment with ID '${experimentId}' not found`);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Delete an experiment by ID.
     *
     * @param experimentId The ID of the experiment to delete
     * @returns Promise<ExperimentResponse> containing the deleted experiment data
     * @throws Error If input validation fails or experiment is not found
     */
    async delete(experimentId) {
        this._validateExperimentId(experimentId);
        const url = `${this.baseUrl}/api/public/experiments/${experimentId}`;
        const response = await fetch(url, {
            method: 'DELETE',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            if (response.status === 404) {
                throw new Error(`Experiment with ID '${experimentId}' not found`);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
}
exports.ExperimentsClient = ExperimentsClient;
/**
 * Convenience wrapper for experiment operations.
 *
 * Provides a simple interface for experiment-level operations.
 */
class Experiments {
    /**
     * Initialize with an experiments client.
     *
     * @param client The experiments client instance
     */
    constructor(client) {
        this._client = client;
    }
    /**
     * Create a new experiment.
     *
     * @param requestData The experiment creation request data
     * @returns Promise<ExperimentResponse> containing the created experiment
     */
    async create(requestData) {
        return this._client.create(requestData);
    }
    /**
     * List experiments with pagination.
     *
     * @param limit Maximum number of experiments to return (default: 50)
     * @param page Page number for pagination (default: 1)
     * @returns Promise<ListExperimentsResponse> containing the list of experiments and total count
     */
    async list(limit = 50, page = 1) {
        return this._client.list(limit, page);
    }
    /**
     * Get a single experiment by ID.
     *
     * @param experimentId The ID of the experiment to retrieve
     * @returns Promise<ExperimentResponse> containing the experiment data
     */
    async find(experimentId) {
        return this._client.find(experimentId);
    }
    /**
     * Delete an experiment by ID.
     *
     * @param experimentId The ID of the experiment to delete
     * @returns Promise<ExperimentResponse> containing the deleted experiment data
     */
    async delete(experimentId) {
        return this._client.delete(experimentId);
    }
}
exports.Experiments = Experiments;
/**
 * Factory function to create an Experiments instance with credentials.
 *
 * @param baseUrl The base URL for the TestOps API
 * @param publicKey The public API key
 * @param secretKey The secret API key
 * @returns A new Experiments instance
 */
function createExperiments(baseUrl, publicKey, secretKey) {
    const client = new ExperimentsClient(baseUrl, publicKey, secretKey);
    return new Experiments(client);
}
//# sourceMappingURL=experiments.js.map