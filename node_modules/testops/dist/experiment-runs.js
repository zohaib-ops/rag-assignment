"use strict";
/**
 * Experiment Runs API client for TestOps.
 *
 * This module provides CRUD operations for experiment runs through the TestOps API.
 * Mirrors the Python SDK's experiment_runs.py structure exactly.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExperimentRuns = exports.ExperimentRunsClient = exports.ExperimentRunStatus = void 0;
exports.createExperimentRuns = createExperimentRuns;
const experiment_types_1 = require("./types/experiment-types");
// Re-export types for convenience
var experiment_types_2 = require("./types/experiment-types");
Object.defineProperty(exports, "ExperimentRunStatus", { enumerable: true, get: function () { return experiment_types_2.ExperimentRunStatus; } });
/**
 * Client for managing experiment runs through the TestOps API.
 */
class ExperimentRunsClient {
    /**
     * Initialize the experiment runs client.
     *
     * @param baseUrl The base URL for the TestOps API
     * @param publicKey The public API key
     * @param secretKey The secret API key
     */
    constructor(baseUrl, publicKey, secretKey) {
        if (!baseUrl || !publicKey || !secretKey) {
            throw new Error('baseUrl, publicKey, and secretKey are required');
        }
        this.baseUrl = baseUrl.replace(/\/$/, '');
        this.publicKey = publicKey;
        this.secretKey = secretKey;
    }
    /**
     * Generate authentication headers for requests.
     */
    _getAuthHeaders() {
        const authString = Buffer.from(`${this.publicKey}:${this.secretKey}`).toString('base64');
        return {
            'Authorization': `Basic ${authString}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
    }
    /**
     * Validate experiment ID format.
     *
     * @param experimentId The experiment ID to validate
     * @throws Error If the experiment ID is invalid
     */
    _validateExperimentId(experimentId) {
        if (!experimentId || typeof experimentId !== 'string') {
            throw new Error('experiment_id must be a non-empty string');
        }
    }
    /**
     * Validate experiment run ID format.
     *
     * @param experimentRunId The experiment run ID to validate
     * @throws Error If the experiment run ID is invalid
     */
    _validateExperimentRunId(experimentRunId) {
        if (!experimentRunId || typeof experimentRunId !== 'string') {
            throw new Error('experiment_run_id must be a non-empty string');
        }
    }
    /**
     * Validate concurrency parameter.
     *
     * @param concurrency The concurrency value to validate
     * @throws Error If the concurrency is invalid
     */
    _validateConcurrency(concurrency) {
        if (concurrency !== undefined && (concurrency < 1 || concurrency > 100)) {
            throw new Error('concurrency must be between 1 and 100');
        }
    }
    /**
     * Validate pagination parameters.
     *
     * @param page The page number to validate
     * @param limit The limit to validate
     * @param maxLimit The maximum allowed limit
     * @throws Error If pagination parameters are invalid
     */
    _validatePaginationParams(page, limit, maxLimit = 1000) {
        if (page < 1) {
            throw new Error('page must be >= 1');
        }
        if (limit < 1 || limit > maxLimit) {
            throw new Error(`limit must be between 1 and ${maxLimit}`);
        }
    }
    /**
     * Create a new experiment run.
     *
     * @param experimentId The ID of the experiment to run
     * @param llmColumnName Optional name of the LLM column
     * @param concurrency Optional concurrency level for the run
     * @param runConfig Optional configuration for the run
     * @returns Promise<ExperimentRunResponse> containing the created experiment run data
     * @throws Error If input validation fails or API request fails
     */
    async create(experimentId, llmColumnName, concurrency, runConfig) {
        this._validateExperimentId(experimentId);
        this._validateConcurrency(concurrency);
        const url = `${this.baseUrl}/api/public/experiment-runs`;
        const payload = {
            experimentId
        };
        if (llmColumnName !== undefined) {
            payload.llmColumnName = llmColumnName;
        }
        if (concurrency !== undefined) {
            payload.concurrency = concurrency;
        }
        if (runConfig !== undefined) {
            payload.runConfig = runConfig;
        }
        const response = await fetch(url, {
            method: 'POST',
            headers: this._getAuthHeaders(),
            body: JSON.stringify(payload),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Find an experiment run by ID.
     *
     * @param experimentRunId The ID of the experiment run to retrieve
     * @returns Promise<ExperimentRunResponse> containing the experiment run data
     * @throws Error If input validation fails or experiment run is not found
     */
    async find(experimentRunId) {
        this._validateExperimentRunId(experimentRunId);
        const url = `${this.baseUrl}/api/public/experiment-runs/${experimentRunId}`;
        const response = await fetch(url, {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * List experiment runs.
     *
     * @param experimentId Optional experiment ID to filter by
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns Promise<ListExperimentRunsResponse> containing experiment runs list and pagination info
     * @throws Error If input validation fails or API request fails
     */
    async list(experimentId, page = 1, limit = 50) {
        if (experimentId !== undefined) {
            this._validateExperimentId(experimentId);
        }
        this._validatePaginationParams(page, limit, 1000);
        const url = new URL(`${this.baseUrl}/api/public/experiment-runs`);
        url.searchParams.set('page', page.toString());
        url.searchParams.set('limit', limit.toString());
        if (experimentId !== undefined) {
            url.searchParams.set('experimentId', experimentId);
        }
        const response = await fetch(url.toString(), {
            method: 'GET',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Delete an experiment run by ID.
     *
     * @param experimentRunId The ID of the experiment run to delete
     * @returns Promise<ExperimentRunResponse> containing the deleted experiment run data
     * @throws Error If input validation fails or experiment run is not found
     */
    async delete(experimentRunId) {
        this._validateExperimentRunId(experimentRunId);
        const url = `${this.baseUrl}/api/public/experiment-runs/${experimentRunId}`;
        const response = await fetch(url, {
            method: 'DELETE',
            headers: this._getAuthHeaders(),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Update an experiment run.
     *
     * @param experimentRunId The ID of the experiment run to update
     * @param updateData Update parameters (status, result, etc.)
     * @returns Promise<ExperimentRunResponse> containing the updated experiment run data
     * @throws Error If input validation fails or experiment run is not found
     */
    async update(experimentRunId, updateData) {
        this._validateExperimentRunId(experimentRunId);
        const url = `${this.baseUrl}/api/experiment-runs/${experimentRunId}`;
        // Filter out undefined values
        const filteredUpdateData = Object.fromEntries(Object.entries(updateData).filter(([, value]) => value !== undefined));
        const response = await fetch(url, {
            method: 'PUT',
            headers: this._getAuthHeaders(),
            body: JSON.stringify(filteredUpdateData),
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
    }
    /**
     * Subscribe to experiment run updates by polling the API.
     *
     * This method polls the experiment run status until it reaches a terminal state.
     * Uses async/await for non-blocking polling.
     *
     * @param experimentRunId The ID of the experiment run to monitor
     * @param timeout Optional timeout in milliseconds for the subscription (default: 120000 for 2 minutes)
     * @param pollInterval Time in milliseconds between polls (default: 5000)
     * @returns Promise<ExperimentRunSubscriptionResult> containing final status and experiment run data
     * @throws Error If input validation fails or subscription times out
     */
    async subscribe(experimentRunId, timeout = 120000, pollInterval = 5000) {
        this._validateExperimentRunId(experimentRunId);
        const startTime = Date.now();
        const terminalStates = [
            experiment_types_1.ExperimentRunStatus.COMPLETED,
            experiment_types_1.ExperimentRunStatus.FAILED,
            experiment_types_1.ExperimentRunStatus.CANCELLED
        ];
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // Check timeout
            if (timeout && (Date.now() - startTime) > timeout) {
                const timeoutData = await this.find(experimentRunId);
                return {
                    finalStatus: 'TIMEOUT',
                    experimentRunData: timeoutData
                };
            }
            const experimentRun = await this.find(experimentRunId);
            if (terminalStates.includes(experimentRun.status)) {
                return {
                    finalStatus: experimentRun.status,
                    experimentRunData: experimentRun
                };
            }
            // Wait before next poll
            await new Promise(resolve => setTimeout(resolve, pollInterval));
        }
    }
}
exports.ExperimentRunsClient = ExperimentRunsClient;
/**
 * Convenience wrapper for experiment runs operations.
 *
 * Provides a simple interface for experiment run-level operations.
 */
class ExperimentRuns {
    /**
     * Initialize with an experiment runs client.
     *
     * @param client The experiment runs client instance
     */
    constructor(client) {
        this._client = client;
    }
    /**
     * Create a new experiment run.
     *
     * @param experimentId The ID of the experiment to run
     * @param llmColumnName Optional name of the LLM column
     * @param concurrency Optional concurrency level for the run
     * @param runConfig Optional configuration for the run
     * @returns Promise<ExperimentRunResponse> containing the created experiment run data
     */
    async create(experimentId, llmColumnName, concurrency, runConfig) {
        return this._client.create(experimentId, llmColumnName, concurrency, runConfig);
    }
    /**
     * Find an experiment run by ID.
     *
     * @param experimentRunId The ID of the experiment run to retrieve
     * @returns Promise<ExperimentRunResponse> containing the experiment run data
     */
    async find(experimentRunId) {
        return this._client.find(experimentRunId);
    }
    /**
     * List experiment runs.
     *
     * @param experimentId Optional experiment ID to filter by
     * @param page Page number for pagination (starts at 1)
     * @param limit Number of items per page
     * @returns Promise<ListExperimentRunsResponse> containing experiment runs list and pagination info
     */
    async list(experimentId, page = 1, limit = 50) {
        return this._client.list(experimentId, page, limit);
    }
    /**
     * Delete an experiment run by ID.
     *
     * @param experimentRunId The ID of the experiment run to delete
     * @returns Promise<ExperimentRunResponse> containing the deleted experiment run data
     */
    async delete(experimentRunId) {
        return this._client.delete(experimentRunId);
    }
    /**
     * Update an experiment run.
     *
     * @param experimentRunId The ID of the experiment run to update
     * @param updateData Update parameters (status, result, etc.)
     * @returns Promise<ExperimentRunResponse> containing the updated experiment run data
     */
    async update(experimentRunId, updateData) {
        return this._client.update(experimentRunId, updateData);
    }
    /**
     * Subscribe to experiment run updates by polling the API.
     *
     * @param experimentRunId The ID of the experiment run to monitor
     * @param timeout Optional timeout in milliseconds for the subscription (default: 120000)
     * @param pollInterval Time in milliseconds between polls (default: 5000)
     * @returns Promise<ExperimentRunSubscriptionResult> containing final status and experiment run data
     */
    async subscribe(experimentRunId, timeout = 120000, pollInterval = 5000) {
        return this._client.subscribe(experimentRunId, timeout, pollInterval);
    }
}
exports.ExperimentRuns = ExperimentRuns;
/**
 * Factory function to create an ExperimentRuns instance with credentials.
 *
 * @param baseUrl The base URL for the TestOps API
 * @param publicKey The public API key
 * @param secretKey The secret API key
 * @returns A new ExperimentRuns instance
 */
function createExperimentRuns(baseUrl, publicKey, secretKey) {
    const client = new ExperimentRunsClient(baseUrl, publicKey, secretKey);
    return new ExperimentRuns(client);
}
//# sourceMappingURL=experiment-runs.js.map